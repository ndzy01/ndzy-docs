---
title: 常见算法
order: 2996
---

## 排序算法

1. 冒泡排序（Bubble Sort）：通过相邻元素的比较和交换来将较大（或较小）的元素逐渐移动到数组的一端。
2. 插入排序（Insertion Sort）：将数组分为已排序和未排序两部分，不断将未排序部分的元素插入到已排序部分的正确位置上。
3. 选择排序（Selection Sort）：在未排序部分选择最小（或最大）的元素，并将其与未排序部分的第一个元素交换位置。
4. 快速排序（Quick Sort）：选择一个基准元素，将数组分成小于基准值和大于基准值的两部分，然后递归地对这两部分进行排序。
5. 归并排序（Merge Sort）：将数组递归地拆分成两个子数组，对子数组进行排序，然后再将两个有序子数组合并成一个有序数组。
6. 堆排序（Heap Sort）：通过构建最大堆（或最小堆）来对数组进行排序，每次将堆顶元素与最后一个元素交换，并重新调整堆。
7. 计数排序（Counting Sort）：统计数组中每个元素的个数，然后根据统计信息将元素放置到正确的位置上。
8. 桶排序（Bucket Sort）：将元素根据大小分配到不同的桶中，对每个桶中的元素进行排序，然后按照顺序将桶中的元素合并。
9. 基数排序（Radix Sort）：按照元素的位数进行排序，从最低位到最高位依次进行排序，每一位使用稳定的排序算法。

### 冒泡排序

冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地依次比较相邻的两个元素，如果它们的顺序错误就交换它们，直到整个数组排序完成。具体步骤如下：

1. 从待排序的数组中的第一个元素开始，依次比较相邻的两个元素。
2. 如果前一个元素大于后一个元素，则交换它们的位置。
3. 继续对每一对相邻元素进行比较和交换，直到到达数组的最后一个元素。
4. 重复上述步骤，每次循环将待排序的元素个数减一，直到没有需要比较的元素。
5. 当没有发生交换时，排序完成。

下面是冒泡排序的示例代码（使用 JavaScript 实现）：

```js
function bubbleSort(arr) {
  var len = arr.length;
  var swapped;

  for (var i = 0; i < len - 1; i++) {
    swapped = false;
    for (var j = 0; j < len - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        // 交换位置
        var temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
        swapped = true;
      }
    }
    // 如果没有发生交换，说明已经排序完成
    if (!swapped) {
      break;
    }
  }

  return arr;
}

// 示例用法
var arr = [5, 3, 8, 1, 4];
console.log(bubbleSort(arr)); // 输出：[1, 3, 4, 5, 8]
```

冒泡排序的时间复杂度为 O(n^2)，在最坏情况下需要进行 n(n-1)/2 次比较和交换。由于其简单直观的实现方式，冒泡排序通常用于教学和理解排序算法的概念，但对于较大规模的数据排序来说，它的性能相对较差。

### 插入排序

插入排序（Insertion Sort）是一种简单直观的排序算法，它将数组分为已排序和未排序两部分，每次从未排序部分选择一个元素插入到已排序部分的正确位置上。具体步骤如下：

1. 从第二个元素开始，将其视为已排序部分。
2. 取出下一个未排序的元素，在已排序部分从后往前依次与已排序元素比较。
3. 如果已排序元素大于取出的元素，则将已排序元素向后移动一位，给取出的元素插入空出的位置。
4. 重复步骤 3，直到找到插入的位置。
5. 将取出的元素插入到已排序部分的正确位置上。
6. 重复步骤 2 至 5，直到所有元素都排序完成。

下面是插入排序的示例代码（使用 JavaScript 实现）：

```js
function insertionSort(arr) {
  var len = arr.length;

  for (var i = 1; i < len; i++) {
    var current = arr[i];
    var j = i - 1;

    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j];
      j--;
    }

    arr[j + 1] = current;
  }

  return arr;
}

// 示例用法
var arr = [5, 3, 8, 1, 4];
console.log(insertionSort(arr)); // 输出：[1, 3, 4, 5, 8]
```

### 选择排序

选择排序（Selection Sort）是一种简单的排序算法，它每次从未排序的部分选择最小（或最大）的元素，并将其放置在已排序部分的末尾。具体步骤如下：

1. 将数组分为已排序和未排序两部分，初始时已排序部分为空。
2. 在未排序部分选择最小（或最大）的元素。
3. 将选出的最小（或最大）元素与未排序部分的第一个元素交换位置，将其放置在已排序部分的末尾。
4. 将已排序部分的末尾向后移动一位。
5. 重复步骤 2 至 4，直到所有元素都排序完成。

下面是选择排序的示例代码（使用 JavaScript 实现）：

```js
function selectionSort(arr) {
  var len = arr.length;

  for (var i = 0; i < len - 1; i++) {
    var minIndex = i;

    // 在未排序部分查找最小元素的索引
    for (var j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }

    // 将找到的最小元素与未排序部分的第一个元素交换位置
    var temp = arr[i];
    arr[i] = arr[minIndex];
    arr[minIndex] = temp;
  }

  return arr;
}

// 示例用法
var arr = [5, 3, 8, 1, 4];
console.log(selectionSort(arr)); // 输出：[1, 3, 4, 5, 8]
```

选择排序的时间复杂度为 O(n^2)，在最坏情况下需要进行 n(n-1)/2 次比较和 n 次交换。尽管选择排序在大规模数据上的性能相对较差，但它的优点是简单直观，且不涉及大量的元素交换。选择排序是一种不稳定的排序算法，相同元素的相对顺序有可能发生改变。

### 快速排序

快速排序（Quick Sort）是一种高效的排序算法，采用分治的思想进行排序。它选择一个基准元素，将数组分成小于基准值和大于基准值的两部分，然后递归地对这两部分进行排序。具体步骤如下：

1. 选择一个基准元素（通常是数组中的第一个元素）。
2. 将数组分成两部分，小于基准值的元素放在左边，大于基准值的元素放在右边，相同值的元素可以放在任一侧。
3. 对左右两部分分别递归地进行快速排序，直到每个部分只有一个元素或为空。
4. 将左半部分、基准元素和右半部分按顺序合并，得到最终的排序结果。

下面是快速排序的示例代码（使用 JavaScript 实现）：

```js
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  var pivotIndex = Math.floor(arr.length / 2);
  var pivot = arr.splice(pivotIndex, 1)[0];
  var left = [];
  var right = [];

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  return quickSort(left).concat([pivot], quickSort(right));
}

// 示例用法
var arr = [5, 3, 8, 1, 4];
console.log(quickSort(arr)); // 输出：[1, 3, 4, 5, 8]
```

快速排序的时间复杂度为 O(nlogn)，在平均情况下具有较好的性能。然而，在最坏情况下，快速排序可能会退化为 O(n^2)的时间复杂度，这取决于选择的基准元素和数据的分布情况。为了优化快速排序的性能，可以选择合适的基准元素，比如随机选择基准元素或者使用三数取中法来选取基准值。快速排序是一种不稳定的排序算法，相同元素的相对顺序有可能发生改变。

### fiber 算法 （协调 调度）

React Fiber（React 纤维）是 React 中的一种新的渲染算法，它是对传统的栈式调用的渲染方式的一种改进。React Fiber 的设计目标是提高 React 在处理大型和复杂应用时的性能和用户体验。

React Fiber 的主要特点和算法包括：

异步渲染：传统的渲染方式是同步的，即一旦开始渲染，就会一直执行直到渲染完成。而 React Fiber 采用了异步渲染的方式，可以将渲染工作分解成多个小任务，中途可以中断和恢复。这样可以提高应用的响应性，避免阻塞主线程，优化用户体验。

优先级调度：React Fiber 在任务调度上引入了优先级的概念。通过将任务分为不同的优先级，可以根据任务的紧急程度和重要性来调度任务的执行顺序，保证高优先级的任务能够更快地得到处理，提高应用的响应速度。

增量渲染：React Fiber 实现了增量渲染，即将整个渲染过程拆分成多个步骤，每次只更新部分内容。这样可以避免长时间的渲染阻塞，提高用户的交互和响应体验。

错误边界：React Fiber 引入了错误边界的概念，可以捕获组件渲染过程中的错误，避免整个应用崩溃，提高应用的稳定性和容错性。

总结来说，React Fiber 是一种新的渲染算法，通过异步渲染、优先级调度、增量渲染等技术手段，提高了 React 应用在处理复杂场景下的性能和用户体验，并引入了错误边界的机制来增加应用的稳定性。

## react useState

React 的 useState 函数是 React 提供的一个钩子函数，用于在函数组件中添加状态。它的实现原理可以简单描述如下：

创建 Fiber：当一个函数组件被调用时，React 会创建一个 Fiber 对象来表示该组件的状态和相关信息。

初始化 Hook：在创建 Fiber 时，React 会初始化一个 Hook 链表，用于保存组件的状态和更新函数。每个 Hook 节点包含一个状态值和一个与之对应的更新函数。

记录状态和更新函数：当调用 useState 时，React 会在 Hook 链表中添加一个新的节点。该节点的状态值初始化为传入的初始值，更新函数用于更新状态值。

返回状态和更新函数： useState 函数返回一个数组，包含当前状态值和对应的更新函数。

更新状态：当调用更新函数时，React 会根据 Fiber 的调度算法进行状态更新。更新函数可以接受新的状态值作为参数，并将新的状态值保存到对应的 Hook 节点中。

触发组件重新渲染：在状态更新后，React 会根据 Fiber 的调度算法判断是否需要重新渲染组件。如果需要重新渲染，React 会调用组件函数，生成新的 JSX 元素，然后进行 Diff 算法对比并更新实际的 DOM 节点。

需要注意的是，上述描述只是对 useState 的一个简化概述，真实的 useState 实现涉及到更多的细节和优化，例如批量更新、状态的订阅和通知机制等。此外，useState 还可以通过闭包和引用传递等技术，保持状态在组件函数多次调用之间的持久性。这使得 useState 在函数组件中可以方便地管理和更新状态。

## Reflection

在 JavaScript 中，反射（Reflection）是指在运行时动态地获取和操作对象的属性和方法。JavaScript 提供了一些内置的反射相关的函数和特性，使得开发者可以在运行时对对象进行检查、访问和修改。

以下是一些常用的 JavaScript 反射方法和特性：

typeof 操作符：用于检查一个变量的数据类型，可以返回 "number"、"string"、"boolean"、"object"、"function"、"undefined" 和 "symbol" 等。

instanceof 操作符：用于检查一个对象是否属于某个特定类型（或其派生类型）的实例。它会根据对象的原型链进行检查。

Object.prototype.toString：通过调用 Object 对象的 toString 方法，可以获取一个对象的详细类型信息，返回一个字符串表示对象的类型。

Object.keys 和 Object.getOwnPropertyNames：用于获取一个对象的所有可枚举属性或所有属性的名称数组。

Reflect 对象：Reflect 对象是 ES6 引入的一个新的内置对象，它提供了一些用于操作对象的方法，比如 Reflect.get、Reflect.set、Reflect.has 等。这些方法可以用于在运行时动态地读取和修改对象的属性和执行对象的方法。

Proxy 对象：Proxy 对象是 ES6 引入的另一个新的内置对象，它可以用来创建一个代理对象，可以拦截并定制对目标对象的操作。通过 Proxy，开发者可以在对象的访问、赋值、删除等操作中添加自定义的逻辑。

这些反射方法和特性使得开发者可以在运行时对对象进行检查和操作，非常灵活和强大。但需要注意的是，过度使用反射可能会导致代码可读性和性能上的问题，因此在使用反射时需要谨慎考虑。
